#!/usr/bin/env python3
"""
dump-files: Concatenate file contents into a single text file with path headers.

Usage:
    dump-files /path/to/folder /path/to/file /path/to/glob/*.conf
    dump-files -o output.txt src/ README.md config/*.yaml

Output format:
    [{relative/path/to/file}]
    <file contents>

Each entry is separated by a blank line.
"""

import argparse
import base64
import glob
import mimetypes
import os
import sys
from pathlib import Path
import gzip
import shutil
import subprocess


try:
  import magic
  def _guess_mime(filepath: Path) -> str:
    return magic.from_file(str(filepath), mime=True)
except ImportError:
  def _guess_mime(filepath: Path) -> str:
    return mimetypes.guess_type(str(filepath))[0] or "application/octet-stream"


def resolve_inputs(patterns: list[str]) -> list[Path]:
  """
  Resolve a list of input patterns into a sorted, deduplicated list of file paths.

  Each pattern can be:
    - A directory: recursively includes all files within it.
    - A file: includes that file directly.
    - A glob pattern: includes all matching files.
  """
  files: set[Path] = set()

  for pattern in patterns:
    path = Path(pattern)

    if path.is_dir():
      for child in path.rglob("*"):
        if child.is_file():
          files.add(child.resolve())
    elif path.is_file():
      files.add(path.resolve())
    else:
      # Treat as a glob pattern
      for match in glob.glob(pattern, recursive=True):
        match_path = Path(match)
        if match_path.is_file():
          files.add(match_path.resolve())

  return sorted(files)


def build_output(files: list[Path], verbose: bool, base_dir: Path | None = None) -> str:
  """
  Build the concatenated output string.

  Each file is represented as:
      [{relative_or_absolute_path}]
      mime-type={mime_type}
      [encoding=base64]
      ======...
      <contents>
      ======...

  Entries are separated by a blank line.

  If base_dir is provided, paths are shown relative to it.
  Otherwise, paths are shown relative to cwd.

  Text files are included as-is. Binary files are base64-encoded.
  """
  if base_dir is None:
    base_dir = Path.cwd()

  sections: list[str] = []

  total_input_bytes = 0

  for filepath in files:
    if verbose:
      start(f"adding: {filepath}")

    total_input_bytes = total_input_bytes + os.path.getsize(filepath)

    try:
      display_path = filepath.relative_to(base_dir)
    except ValueError:
      display_path = filepath

    mime_type = _guess_mime(filepath)
    is_binary = not mime_type.startswith("text/")

    try:
      if is_binary:
        raw = filepath.read_bytes()
        content = base64.b64encode(raw).decode("ascii")
      else:
        content = filepath.read_text(encoding="utf-8")
    except UnicodeDecodeError:
      # mime type said text, but contents aren't valid UTF-8
      raw = filepath.read_bytes()
      content = base64.b64encode(raw).decode("ascii")
      is_binary = True
    except OSError as exc:
      fail()
      print(f"Warning: skipping {filepath}: {exc}", file=sys.stderr)
      continue

    header = f"[{display_path}]"
    meta = f"mime-type={mime_type}"
    if is_binary:
      meta += "\nencoding=base64"
    line = "=" * max(len(header), len(str(display_path)) + 2)
    sections.append(f"{header}\n{meta}\n{line}\n{content}\n{line}")
    ok()

  print(f"total input size: {human_readable_filesize(total_input_bytes)}")
  start("serialising... ")
  result = "\n\n".join(sections) + "\n" if sections else ""
  ok()
  return result


def build_parser() -> argparse.ArgumentParser:
  parser = argparse.ArgumentParser(
    prog="dump-files",
    description="Dump file contents into a single text file with path headers.",
  )
  parser.add_argument(
    "inputs",
    nargs="*",
    metavar="PATH",
    help="Files, directories, or glob patterns to include.",
  )
  parser.add_argument(
    "-o",
    "--output",
    default=None,
    help="Output file path. Defaults to stdout.",
  )
  parser.add_argument(
    "-n",
    "--no-compress",
    action="store_true",
    help="When output file path is provided, don't compress the contents"
  )
  parser.add_argument(
    "-q",
    "--quiet",
    action="store_true",
    help="Suppress printing out file paths as they are being added to the dump"
  )
  parser.add_argument(
    "--test",
    action="store_true",
    help="Run the built-in test suite and exit.",
  )
  return parser

def start(label: str) -> None:
  print(f"{label}...  ", end="", flush=True)

def ok() -> None:
  print("ok")

def fail() -> None:
  print("fail")

def file_size_from_path(path: str) -> str:
    size = os.path.getsize(path)
    return human_readable_filesize(size)

def human_readable_filesize(size_in_bytes: int) -> str:
  if size_in_bytes < 1024:
    return f"{size_in_bytes}b"
  elif size_in_bytes < 1048576:
    return f"{size_in_bytes / 1024:.1f}kb"
  else:
    return f"{size_in_bytes / 1048576:.1f}mb"

def write_compressed(text: str, target: str) -> None:
  target_path = Path(target)
  target_path.unlink(missing_ok=True)

  if shutil.which("pigz"):
    # Write plain text file without .gz extension
    plain_path = target_path.with_suffix("") if target_path.suffix == ".gz" else target_path
    start(f"writing intermediate file")
    plain_path.write_text(text, encoding="utf-8")
    ok()
    start("compressing with pigz")
    subprocess.run(["pigz", str(plain_path)], check=True)
    ok()
    # pigz produces <filename>.gz, rename if target differs
    pigz_output = plain_path.with_suffix(plain_path.suffix + ".gz")
    if pigz_output != target_path:
      pigz_output.rename(target_path)
  else:
    start("compressing")
    compressed = gzip.compress(text.encode("utf-8"))
    ok()
    start("writing file... ")
    target_path.write_bytes(compressed)
    ok()

def main(argv: list[str] | None = None) -> int:
  parser = build_parser()
  args = parser.parse_args(argv)

  if args.test:
    try:
      import pytest  # noqa: F811
    except ImportError:
      print("Error: pytest is required to run tests. Install it with: pip install pytest", file=sys.stderr)
      return 1
    # Forward remaining args to pytest (strip --test itself)
    pytest_args = [a for a in (argv or sys.argv[1:]) if a != "--test"]
    return pytest.main([__file__, "-v"] + pytest_args)

  if not args.inputs:
    parser.error("the following arguments are required: PATH")

  files = resolve_inputs(args.inputs)

  if not files:
    print("No files matched the given inputs.", file=sys.stderr)
    return 1

  output = build_output(files, not args.quiet)

  if args.output:
    if not args.no_compress:
      # print("compressing... ", end="", flush=True)
      # compressed = gzip.compress((output.encode("utf-8")))
      # print("ok")
      new_path = Path(args.output).with_suffix(".gz")
      # new_path.write_bytes(compressed)
      write_compressed(output, str(new_path))
      print(f"Wrote {len(files)} file(s) to {new_path} ({file_size_from_path(str(new_path))})", file=sys.stderr)
    else:
      Path(args.output).with_suffix(".txt").write_text(output, encoding="utf-8")
      print(f"Wrote {len(files)} file(s) to {args.output}", file=sys.stderr)
  else:
    sys.stdout.write(output)

  return 0


# ---------------------------------------------------------------------------
# Tests (run with: pytest dump_files.py or python -m pytest dump_files.py)
# ---------------------------------------------------------------------------

try:
  import pytest
except ImportError:
  # Allow the script to be used as a CLI tool without pytest installed.
  # Tests simply won't be collected.
  if __name__ != "__main__":
    raise
  sys.exit(main())


@pytest.fixture
def sample_tree(tmp_path: Path) -> Path:
  """
  Create a sample file tree:

      tmp_path/
      ├── src/
      │   ├── main.py
      │   └── utils/
      │       └── helper.py
      ├── config/
      │   ├── app.conf
      │   └── db.conf
      ├── readme.txt
      └── notes.log
  """
  (tmp_path / "src").mkdir()
  (tmp_path / "src" / "utils").mkdir()
  (tmp_path / "config").mkdir()

  (tmp_path / "src" / "main.py").write_text("print('hello')\n", encoding="utf-8")
  (tmp_path / "src" / "utils" / "helper.py").write_text("def help(): ...\n", encoding="utf-8")
  (tmp_path / "config" / "app.conf").write_text("key=value\n", encoding="utf-8")
  (tmp_path / "config" / "db.conf").write_text("host=localhost\n", encoding="utf-8")
  (tmp_path / "readme.txt").write_text("Read me!\n", encoding="utf-8")
  (tmp_path / "notes.log").write_text("some log\n", encoding="utf-8")

  return tmp_path


class TestResolveInputs:
  def test_single_file(self, sample_tree: Path):
    result = resolve_inputs([str(sample_tree / "readme.txt")])
    assert len(result) == 1
    assert result[0].name == "readme.txt"

  def test_directory_recursive(self, sample_tree: Path):
    result = resolve_inputs([str(sample_tree / "src")])
    names = {f.name for f in result}
    assert names == {"main.py", "helper.py"}

  def test_glob_pattern(self, sample_tree: Path):
    result = resolve_inputs([str(sample_tree / "config" / "*.conf")])
    names = {f.name for f in result}
    assert names == {"app.conf", "db.conf"}

  def test_mixed_inputs(self, sample_tree: Path):
    result = resolve_inputs([
      str(sample_tree / "src"),
      str(sample_tree / "readme.txt"),
      str(sample_tree / "config" / "*.conf"),
    ])
    names = {f.name for f in result}
    assert names == {"main.py", "helper.py", "readme.txt", "app.conf", "db.conf"}

  def test_deduplication(self, sample_tree: Path):
    result = resolve_inputs([
      str(sample_tree / "readme.txt"),
      str(sample_tree / "readme.txt"),
    ])
    assert len(result) == 1

  def test_no_matches_returns_empty(self, tmp_path: Path):
    result = resolve_inputs([str(tmp_path / "nonexistent_*.xyz")])
    assert result == []

  def test_sorted_output(self, sample_tree: Path):
    result = resolve_inputs([str(sample_tree)])
    assert result == sorted(result)


class TestBuildOutput:
  def test_output_format(self, sample_tree: Path):
    files = [sample_tree / "readme.txt"]
    output = build_output(files, False, base_dir=sample_tree)

    assert "[readme.txt]" in output
    assert "mime-type=text/plain" in output
    assert "Read me!" in output
    assert "encoding=base64" not in output

  def test_multiple_files_separated_by_blank_line(self, sample_tree: Path):
    files = sorted([
      sample_tree / "config" / "app.conf",
      sample_tree / "config" / "db.conf",
    ])
    output = build_output(files, base_dir=sample_tree)

    assert "[config/app.conf]" in output
    assert "[config/db.conf]" in output
    # Sections separated by double newline
    sections = output.strip().split("\n\n")
    assert len(sections) == 2

  def test_relative_paths(self, sample_tree: Path):
    files = [sample_tree / "src" / "utils" / "helper.py"]
    output = build_output(files, base_dir=sample_tree)

    assert output.startswith("[src/utils/helper.py]")

  def test_empty_input(self):
    assert build_output([]) == ""

  def test_binary_file_base64_encoded(self, sample_tree: Path):
    bin_file = sample_tree / "binary.bin"
    bin_data = b"\x80\x81\x82" * 100
    bin_file.write_bytes(bin_data)

    files = [sample_tree / "readme.txt", bin_file]
    output = build_output(files, False, base_dir=sample_tree)

    # Should contain both files
    assert "[readme.txt]" in output
    assert "[binary.bin]" in output
    # Binary file should have base64 encoding header
    assert "encoding=base64" in output
    assert "mime-type=application/octet-stream" in output
    # Verify the base64 content decodes back correctly
    import base64 as b64
    encoded = b64.b64encode(bin_data).decode("ascii")
    assert encoded in output


class TestCLIIntegration:
  def test_output_to_file(self, sample_tree: Path, tmp_path: Path):
    out_file = tmp_path / "dump.txt"
    rc = main([
      str(sample_tree / "readme.txt"),
      "-o", str(out_file),
    ])
    assert rc == 0
    content = out_file.read_text(encoding="utf-8")
    assert "Read me!" in content

  def test_mixed_inputs_to_file(self, sample_tree: Path, tmp_path: Path):
    out_file = tmp_path / "dump.txt"
    rc = main([
      str(sample_tree / "src"),
      str(sample_tree / "readme.txt"),
      str(sample_tree / "config" / "*.conf"),
      "-o", str(out_file),
    ])
    assert rc == 0
    content = out_file.read_text(encoding="utf-8")
    assert "print('hello')" in content
    assert "Read me!" in content
    assert "key=value" in content

  def test_stdout_default(self, sample_tree: Path, capsys):
    rc = main([str(sample_tree / "readme.txt")])
    assert rc == 0
    captured = capsys.readouterr()
    assert "[" in captured.out
    assert "Read me!" in captured.out

  def test_no_matches_returns_error(self, tmp_path: Path):
    rc = main([str(tmp_path / "nope_*.xyz")])
    assert rc == 1

  def test_output_file_header_format(self, sample_tree: Path, tmp_path: Path):
    out_file = tmp_path / "dump.txt"
    main([
      str(sample_tree / "config" / "app.conf"),
      "-o", str(out_file),
    ])
    content = out_file.read_text(encoding="utf-8")
    lines = content.splitlines()
    # First line should be a header in [path] format
    assert lines[0].startswith("[")
    assert lines[0].endswith("]")


if __name__ == "__main__":
  sys.exit(main())
